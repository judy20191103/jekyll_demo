一：什么是事件冒泡
当事件发生后，这个事件就要开始传播。为什么传播呢？因为事件源本身（maybe)并没有处理事件的能力，即处理事件的函数
方法并没有绑定在该事件源上。例如点击一个按钮的时候，就会产生一个click事件，但是这个按钮本身可能不能处理这个事件，事件必须从
这个按钮传播出去，从而到达能够处理这个事件的代码中，例如给按钮的onclick属性赋给一个函数的名字，就是让这个函数去
处理该按钮的click事件，或者按钮的父级绑定有该事件的处理函数（click),当点击事件发生在按钮上，按钮本身并无处理事件函数，
则传播到父级去处理。

二：事件冒泡的优缺点
1:那些需要创建的以及驻留在内存中的事件处理器少了
这是很重要的一点，这样就提高了性能，并降低了奔溃的风险
2：在DOM更新后无需重新绑定事件处理器

三：不是所有的事件都能冒泡
blur,focus,load,unload不能像其他事件一样冒泡。事实上blur,focus可以用事件捕获而非事件冒泡的方法获得
（在IE之外的其他浏览器中）
需要注意的是：如果代码处理mousemove事件的话遇上性能瓶颈的风险就大了，因为mousemove事件触发非常频繁。
而mousemove则因其怪异的表现变得很难用事件代理管理。

ev=ev.event||window.event;
ev.stopPropagation;//非ie
ev.cancelBubble=true;//ie

ev。target||ev.srcElement
