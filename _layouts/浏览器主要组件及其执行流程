组件： 
1：用户界面： 用户界面包含了地址栏，前进后退按钮，书签菜单等，除了请求页面之素有你能看到的内容都是用户界面的一部分。
2: 浏览器引擎： 浏览器引擎负责让UI和渲染引擎协调工作。
3: 渲染引擎：渲染引擎负责展示请求内容，如果请求的内容是HTML，渲染引擎会解析HTML和CSS， 然后将其展示在屏幕上
4: 网络组件，网络组件负责网络调用，例如HTTP请求等，使用一个平台无关接口，下层是针对不同平台的具体实现
5：UI后端，UI后端用于绘制基本的UI组件，例如下栏列表框和窗口，UI后端暴露一个统一的平台无关接口，下层使用操作系统的UI实现方式
6: javascript 解析器，用于解析和执行javascript代码
7：数据存储，数据存储组件是一个持久层，浏览器可能需要在本地存储各种各样的数据，Cookie, localStorage,IndexedDB,WebSQL,FileSystem.

解析和渲染流程
Loading->parsing->rending->layout->painting

浏览器的加载顺序
navigationStart: 在导航开始的时候，在浏览器开始卸载前一页（如果有这样页面的时候），或者在开始提取页面的时候，捕获所需的数据。它将
包含unloadEventStart数据或fetchStart数据。要想跟踪端到端的时间，可以使用这个指开始。
unloadEventStart/ unloadEventEnd: 在浏览器开始卸载前一页或者已经完成前一页卸载的时候，捕获
所需的数据（如果有相同域中前一页需要卸载的话
domainLookupStart/domainLookupEnd: 在浏览器开始和完成请求内容的DNS查找时，捕获所需的数据。
redirectStart/redirectEnd: 在浏览器开始和完成建立当前页面的远程服务器TCP连接时所捕获
的数据。
 

浏览器呈现网页的处理流程图
Parsing HTML to construct the DOM tree -> Rending tree construction -> Layout of the render tree- >Painting the render tree

1: 渲染引擎把HTML文档解析成 DOM树，把标签转换成DOM节点
2: Gecko(Firefox): 在解析HTML文档的同时，渲染引擎会把文档内的样式和外部CSS文件解析成CSS规则树
而Webkit 不会生成CSS规则树
3: 渲染器是在文档内解析和创建DOM节点后创建的，会计算DOM节点的样式信息。如果元素的display属性被设置成了none,或者如果元素的子孙
继承了display:none,该元素的渲染器不会被创建。节点的子类和display属性一起决定了什么样的渲染器，渲染器是渲染树的节点。
Gecko(Firefox):DOM树和CSS规则树结合之后，形成了Style Content Tree.将Style Content Tree 和渲染树关联，就完成了渲染树
渲染树包含了多个视觉信息（如颜色和尺寸等）矩形，这些矩形的排列顺序是在屏幕上显示的顺序。
4: 渲染树构建出来之后，就进入布局阶段，为渲染树的每个节点分配一个屏幕上的确切坐标
5: 最后一部，就是遍历渲染树，通过用户界面后端（UI Backend)将每个节点绘制出来
这是一个渐进过程，渲染引擎不会等到把整个HTML文档解析完成之后，才开始构建渲染树和确定布局，在不断
接收和处理网络层的请求内容时，渲染引擎会将部分内容解析并显示出来

解析： 将HTML文档转化为DOM树并下载相关资源的过程
HTML 解析器的任务时将HTML标志解析成解析树。
HTML 的词汇和语法在W3C规范中进行了定义
HTML 的定义采用了DTD (documentType Definition， 文档类型定义）
解析树是由DOM（document object model) 元素的属性节点构成的树结构，根节点是Document对象
DOM 与标志是一一对应的。

解析过程
HTML 不能使用常见的自顶向下或自底向上的方法来进行分析，主要原因有以下几点。
语言本身的宽容特性
HTML本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们
解析过程需要反复，对于其他语言来说，源码不会在解析过程中发生变化，但是对于HTML来说，动态代码，例如脚本元素中包含的
document.write()方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容
由于不能使用常用的解析技术，浏览器创造了专门用于解析HTML的解析器。解析算法在HTML5标准中有详细介绍
算法主要包含了两个阶段，标记化和树的构建

标识化： 是词法分析过程，将输入内容解析成多个标志。HTML标志包括起始标志，结束标志，属性名称和属性值。
标志生成器识别标志，传递给树构造器，然后接受下一个字符以识别下一个标志，直到输入的结束

标识化算法： 标识化算法的输入结果是HTML标志，使用状态机表示。状态机一共有4种状态：数据状态（Data),
标志打开状态（Tag open),标志名称状态（Tag name), 关闭标志打开状态（Close tag open state).
初始状态是数据状态
1: 遇到字符<时，状态更改为“标志打开状态":
    a: 接收一个a-z字符会创建"起始标志“，状态更改为"标志名称状态“，并保持到接收">"字符。此期间的字符串会形成一个新的
    标志名称，接收到>标志后，将当前的新标志发送给树构造器，状态改回到"数据状态”。
    b: 接受下一个输入字符/时，会创建关闭标志打开状态，并更改为“ 标志名称状态”，直到接受>字符。
    将当前的新标志发送给树构造器，并改回“数据状态"
    2) 遇到a-z字符时，会将每个字符创建成字符标志，并发送给树构造器。
    
    
    
    












