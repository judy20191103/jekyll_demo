脚本解析： 网络的模型时同步的。网页作者希望解析器遇到<script>标志时立刻解析并执行脚本。文档的解析将停止，直到脚本执行完毕。
如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在HTML4和HTML5规范中进行了指定。作者
也可以将脚本标注为“defer",这样它就不会停止文档解析，而是等到解析结束后才执行。HTML5增加了一个选项，课将脚本标志为异步，以便由其他线程
解析和执行

预解析： webkit和firefox都进行了这项优化，在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要欧
通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高整体速度。请注意，预解析不会修改DOM
树，而是将这项工作交由主解析器处理，预解析器只会解析外部资源（例如外部脚本，样式表和图片）的引用

样式表：另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改DOM树，因此似乎没有必要
等待样式表并停止文档解析。但这设计到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载
和解析衍圣公hi，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去时一个非典型的案例，但事实上非常普遍。Firefox在样式表加载和解析的过程中，
会禁止所有脚本，而对于Webkit而言，仅当脚本尝试访问的样式属性可能受未加载的样式表影响时，它才会禁止该脚本。

呈现树构建
在DOM树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，
也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容
Firefox将呈现树中的元素称为框架，webkit使用的术语是呈现器或呈现对象
呈现器直到如何用布局并将其自身及其子元素绘制出来。

每一个呈现器都代表了一个矩形区域，通常对应于相关节点的CSS框，这一点在CSS2规范中有所描述。它包含诸如宽度，
高度和位置等几何信息。
框的类型会受到与节点相关的display 样式属性的影响。

呈现树和DOM树
呈现树是和DOM元素相对应的，但并非一一对应。非可视化的DOM元素不会插入呈现树中，例如“head"元素。
如果元素的display属性值为"none",那么也不会显示在呈现树中（visibility:hidden的元素仍然会呈现）
有一些DOM元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，select元素有3个
呈现器： 一个用于按钮，如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行会也会作为新的显示器而添加。
另一个关于多呈现器的例子是格式无效的HTML。根据CSS规范，inline元素只能包含了block 元素或inline元素中的一种。
如果出现了混合内容，则应该创建匿名的boock呈现器，以包裹inline元素。有一些呈现对象与i英语DOM节点，但在树中
所在的位置与DOM节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架

构建呈现树的流程
1：在firefox中，系统会针对DOM更新注册展示层，作为侦听器，展示层将框架创建工作委托给FrameConstructor。由该构造器解析样式
并创建框架。
2：在Webkit 中，解析样式和创建呈现器的过程称为”附加”，每个DOM节点都有一个“attach" 方法。附加是同步进行的，将节点插入DOM树需要调用新的节点
”attach"方法
3：处理HTML和body标志就会构建呈现树根节点。这个节点呈现对象对应于CSS规范中所说的容器block,包含了其他所有节点block.
它的尺寸就是视口，即浏览器窗口显示区域的尺寸。firefox称之为ViewPortFrame，而webkit称之为RanderView.
这就是文档所指向的呈现对象，呈现树的其余部分以DOM树节点插入的形式来构建。


样式计算
1: 构建呈现时，需要计算每一个呈现对象的可视化属性。这是通过计算每一个元素的样式属性来完成的。
2: 样式包括各种来源的样式表，inline样式和HTML中的可视化属性（bgcolor).其中后者将经转化以匹配CSS样式属性。
3：样式表的来源包括浏览器的默认样式表，由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您自定义自己
喜欢的样式，firefox,用户可以将自己喜欢的样式表放在firefox profile文件夹下）
4: 样式数据时一个超大的结构，存储了无数的样式属性，这可能造成内存问题。
5： 如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历查找整个规则列表来寻找规则，
这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试
其他匹配路径。
6： 应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。

浏览器是如何处理这些问题的
1： 共享样式数据
2： 结构划分：规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，
则可使用上层节点中的缓存结构。
3： 使用规则树计算特定元素的样式上下文，我们首先计算规则树中的对应路径，或者使用现有的路径。
然后我们沿此路径应用规则。在新的样式上下文中填充结构，我们从路径中拥有最高优先级的底层节点
（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完成
4： 对规则进行处理以简化匹配。














