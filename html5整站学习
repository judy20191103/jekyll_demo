id选择器用于在页面布局中唯一的那一部份，比如header,footer
先观察布局，分成哪几个区域
<div id="top"></div>
<div id="header"></div>
<ul id="nav"></ul>//导航用的
<div id="content"</div>
<div id="footer"></div>


样式重置：ul{padding:0;margin:0;} li{list-style:none}
li样式的左边的实心点在不同的浏览器中是大小不一样的，在firefox中和chrome中一样，在ie中细一些；
所以必须重置，如果真要做实心点可以用图片替代

bpdy,ul,p,h1~h6,dl,dd,form,input,textarea,select{ padding:0; margin:0}
li{list-style:none;} 
img{ border:none;}
a { text-decoration:none;}
a:hover {text-decoration:underline;}
原则：用到什么标签就重置什么标签

裁剪背景图片的原则，采用1px*height的形式，利用拾色器定位，然后下来标尺线进行横向定位，图像-裁剪。
选取图片的格式:在不影响的图片的质量的前提下选取最小的格式。 背景默认设置的白色，万一浏览器右有给用户设置默认背景色的功能，那么我们应该给背景设置一个白色

写完<div class="top_menu"></div> 可以写旗下的细节布局，然后写css. 注：导航部分，一般用ul进行布局

写css样式的时候，尽量简短，能让浏览器识别出独立的样式名而不会相冲突即可。因为浏览器对css样式的解析时从右往左进行的。

从后往前判断。浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，
如果不符合上一个部分，就把元素从集合中删除，直到真个选择器都匹配完，还在集合中的元素就匹配这个选择器了。举个例子，有选择器：
body.ready#wrapper>.lol233
先把所有class中有lol233的元素拿出来组成一个集合，然后上一层，对每一个集合中的元素，如果元素的parent id不为#wrapper则把元素从集合中删去。再向上，
从这个元素的父元素开始向上找，没有找到一个tagName为body且class中有ready的元素，就把原来的元素从集合中删去。至此这个选择器匹配结束，
所有还在集合中的元素满足。大体就是这样，不过浏览器还会有一些奇怪的优化。为什么从后往前匹配因为效率和文档流的解析方向。
效率不必说，找元素的父亲和之前的兄弟比遍历所哟儿子快而且方便。关于文档流的解析方向，是因为现在的CSS，
一个元素只要确定了这个元素在文档流之前出现过的所有元素，就能确定他的匹配情况。应用在即使html没有载入完成，
浏览器也能根据已经载入的这一部分信息完全确定出现过的元素的属性。为什么是用集合主要也还是效率。基于CSS Rule数量远远小于元素数量的假设和索引的运用，
遍历每一条CSS Rule通过集合筛选，比遍历每一个元素再遍历每一条Rule匹配要快得多。


换行符测试自适应高度区域

切图原则:分块切图还是整体切图取决于图片分开切后相加的和是否小于整体切的大小。

javascript:; 是一个伪协议； javascript是表示在触发<a>默认动作时，执行一段javascript代码，而javascript:; 表示什么都不执行，这样
点击<a>时就没有任何反应。
href=“javascript:;" 就是去掉a标签的默认行为，跟href="javascript:void(0)"是一样的。 void 是javascript是一个运算符，void(0)就是什么都不做的意思。


ps中 ctrl+u 调出色相/饱和度的快捷面板
ul一般是相对定位，相对于其父级进行定位

